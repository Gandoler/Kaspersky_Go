## Kaspersky Container Security — Очередь фоновой обработки задач

Внутренний сервис для приёма задач через HTTP и их фоновой обработки пулом воркеров с повторными попытками и экспоненциальным бэкоффом.

### Архитектура (слои)

- `APILevel/HTTPServer`: HTTP-сервер и хендлеры (`/healthz`, `/enqueue`).
- `APILevel/Adapters`: внутренняя реализация адаптеров — буферизированная очередь и хранилище состояний в памяти.
- `ServiceLevel/UseCases/WokerPool`: пул воркеров, забирающий задания из очереди, обновляющий статусы и вызывающий процессор.
- `ServiceLevel/UseCases/Processors`: процессор задач с имитацией работы, отказов, бэкоффа и ретраев.
- `APILevel/Builder`: сборка `App` из компонентов и управление запуском/остановкой (graceful shutdown).
- `ModeLevel/Structures`: типы и состояния задач.

### Запуск

Переменные окружения:
- `WORKERS` — количество воркеров; по заданию значение по умолчанию 4
- `QUEUE_SIZE` — размер буфера очереди; по заданию значение по умолчанию 64

Пример запуска (PowerShell/Unix shell):
```bash
export WORKERS=4
export QUEUE_SIZE=64
go run ./...
```

Примечание: в текущей версии `main.go` требует, чтобы обе переменные были заданы, иначе программа завершится ошибкой конвертации. Это отмечено в чек-листе соответствия как пункт для доработки (см. ниже).

### HTTP API

- `GET /healthz`
  - Ответ: `200 OK`, тело — `OK`

- `POST /enqueue`
  - Тело JSON:
    ```json
    {"id":"<string>","payload":"<string>","max_retries":<int>}
    ```
  - Поведение: задача кладётся в буферизированную очередь, в `state` устанавливается статус `queued`
  - Ответ: `202 Accepted`, тело: `{"status":"queued"}`

### Состояния задач

Определены в `ModeLevel/Structures/Structs.go`:
- `queued`, `running`, `done`, `failed`

### Обработка задач

- Пул воркеров (`WokerPool`): число воркеров настраивается через `WORKERS`.
- Процессор (`RetryProcessor`):
  - имитирует выполнение 100–150 мс в текущей реализации
  - 20% вероятности «падения»
  - экспоненциальный бэкофф c джиттером между ретраями
  - до `max_retries` повторов

### Завершение (graceful shutdown)

`App.Start` перехватывает `SIGINT/SIGTERM`, останавливает HTTP-сервер через `Shutdown(ctx)` и закрывает очередь; воркеры завершаются после обработки текущей задачи (или выхода из канала после `Close()`).

### Тесты

См. `TESTS/README.md`.

Запуск:
```bash
go test ./...
```

---

## Соответствие требованиям задания (Checklist)

Задание: «Необходимо реализовать внутреннюю очередь для фоновой обработки входящих задач»

1) Принимать задания через `POST /enqueue`
- Тело: JSON {"id","payload","max_retries"} — реализовано (`APILevel/HTTPServer/HandleEnqueue`).
- Задание попадает в буферизированную очередь (размер — из конфигурации) — реализовано (`Adapters.MemoryQueue`, создаётся в `AppBuilder` с настраиваемым `QUEUE_SIZE`).
- Авторизация не требуется — выполнено.

2) Обрабатывать задания пулом воркеров (`WORKERS` настраивается)
- WORKERS настраивается — реализовано (читается в `main.go`, передаётся в `AppBuilder`).
- Каждое задание «работает» 100–500 мс — частично: сейчас 100–150 мс. Требуется расширить диапазон до 100–500 мс.
- 20% задач «падают» — реализовано (вероятность 20%).
- Экспоненциальный бэкофф с джиттером — реализовано (`backoff()` в `RetryProcessor`).
- Повторы до `max_retries` — логика ретраев есть; финальный статус при исчерпании повторов сейчас не выставляется в `failed` (см. пункт ниже в «Готово/Доделать»).
- Хранить/обновлять состояния `queued | running | done | failed` — частично: `queued`, `running`, `done` выставляются; `failed` фактически не устанавливается при исчерпании ретраев.

3) Отдавать healthcheck
- `GET /healthz` → `200 OK` — реализовано.

4) Корректно завершать программу по `SIGINT/SIGTERM`
- Перестаём принимать новые запросы — реализовано через `http.Server.Shutdown`.
- Дожидаемся завершения текущих — реализовано: воркеры завершают текущую обработку, затем выходят.

Ограничения
- Go 1.24 — в `go.mod` указано `go 1.24`.
- Без сторонних библиотек — соблюдено (используются стандартные пакеты).
- Конфигурация через переменные окружения: `WORKERS` (по умолчанию 4), `QUEUE_SIZE` (по умолчанию 64) — частично: значения по умолчанию заданы в `AppBuilder`, но `main.go` сейчас требует явного задания переменных и падает при пустых значениях. Нужно добавить реальные дефолты при отсутствии env.
- Краткое описание решения — дано в этом README и комментариях к коду.

### Итог: что готово и что доработать

Готово:
- Эндпоинты `/enqueue` и `/healthz`.
- Буферизированная очередь и пул воркеров, состояния `queued/running/done`.
- Ретраи с экспоненциальным бэкоффом и джиттером (20% фейлов).
- Graceful shutdown.
- Набор автотестов для основных компонентов (см. `TESTS`).

Доработать для полного соответствия формулировке задания:
- Установить реальные дефолты при отсутствии `WORKERS`/`QUEUE_SIZE` (например: если env пуст, брать 4 и 64 соответственно, не паниковать).
- Расширить длительность имитации работы до 100–500 мс.
- Устанавливать статус `failed` при исчерпании `max_retries`.

---

## Сдача задания

Соберите архив/файл с исходниками и укажите фамилию и имя в названии. Загрузите по ссылке: `https://box.kaspersky.com/u/d/b1efd9961a604b4cb8ba/`.


